<!DOCTYPE html>
<html>
<head>
    <title>Visualização de Hierarquia de Indicadores</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        .sector {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .sector-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .root-container {
            margin-bottom: 40px;
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 5px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .root-title {
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            color: #333;
            font-size: 14px;
        }
        .tree-container {
            overflow-x: auto;
        }
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
        }
        .node text {
            font: 12px sans-serif;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        select, button, input {
            padding: 8px 12px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
        }
        .node:hover circle {
            stroke: #333;
            stroke-width: 3px;
        }
        .node:hover text {
            font-weight: bold;
        }
        .level-1 { fill: #1f77b4; }
        .level-2 { fill: #2ca02c; }
        .level-3 { fill: #ff7f0e; }
        .level-4 { fill: #d62728; }
        .level-5 { fill: #9467bd; }
        .level-6 { fill: #8c564b; }
        .file-info {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        .tooltip {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 400px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10;
        }
        .level2-container {
            border: 2px solid #2ca02c;
            background-color: #f4fff4;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .indented-list {
            list-style: none;
            margin-left: 24px;
            padding-left: 12px;
            border-left: 1px solid #ddd;
        }
        .indented-node {
            margin: 4px 0;
            font-size: 14px;
        }
        .indented-label {
            margin-left: 2px;
        }
        .toggle {
            font-weight: bold;
            color: #1f77b4;
            user-select: none;
        }
        /* Add CSS for flex row of Level 2 containers */
        .level2-flex-row {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            margin-bottom: 32px;
        }
        .level2-flex-item {
            flex: 1 1 350px;
            min-width: 320px;
            max-width: 500px;
            box-sizing: border-box;
            margin-bottom: 0;
        }
        .indicator-value {
            display: inline-block;
            min-width: 48px;
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            background: #eee;
            vertical-align: middle;
            transition: background 0.2s;
        }
    </style>
</head>
<body>
    <h1>Visualização de Hierarquia de Indicadores</h1>

    <div class="controls">
        <label for="state-select">Estado:</label>
        <select id="state-select">
            <option value="">Selecione o estado...</option>
        </select>
        <label for="city-select">Cidade:</label>
        <select id="city-select">
            <option value="">Selecione uma cidade...</option>
        </select>
        <br><br>
        <label for="json-file">Arquivo JSON com estrutura:</label>
        <input type="file" id="json-file" accept=".json">
        <div class="file-info" id="file-info">Nenhum arquivo selecionado</div>
        <div style="margin-top: 15px;">
            <label for="sector-filter">Filtrar por Setor:</label>
            <select id="sector-filter">
                <option value="all">Todos os Setores</option>
            </select>
            <label for="level-filter">Filtrar por Nível:</label>
            <select id="level-filter">
                <option value="all">Todos os Níveis</option>
            </select>
            <button id="collapse-all">Recolher Todos</button>
            <button id="expand-all">Expandir Todos</button>
        </div>
    </div>

    <div id="visualization"></div>

    <script>
        // Global variables for the visualization
        let allData, hierarchyData;

        // Function to build hierarchy from flat data
        function buildHierarchy(data) {
            const sectors = {};
            const indicatorMap = {};

            // First, create a map of all indicators by ID
            data.forEach(indicator => {
                // Convert nivel to number for proper sorting
                const nivel = indicator.nivel ? parseInt(indicator.nivel) : 0;
                indicator.nivel_num = nivel;

                indicatorMap[indicator.id] = indicator;
                if (!sectors[indicator.setor_estrategico]) {
                    sectors[indicator.setor_estrategico] = [];
                }
            });

            // Then build the hierarchy for each sector
            const sectorHierarchies = {};
            Object.keys(sectors).forEach(sector => {
                // Find root indicators (those with no parent or parent not in the same sector)
                const roots = data.filter(indicator =>
                    indicator.setor_estrategico === sector &&
                    (!indicator.indicador_pai ||
                     !data.some(i => i.id === indicator.indicador_pai && i.setor_estrategico === sector))
                ).map(indicator => buildTree(indicator, data, sector));

                sectorHierarchies[sector] = roots.length > 0 ? roots : null;
            });

            // Get all unique levels
            const levels = new Set();
            data.forEach(indicator => {
                if (indicator.nivel) levels.add(indicator.nivel);
            });
            // Sort levels numerically
            const sortedLevels = Array.from(levels)
                .map(l => parseInt(l))
                .sort((a, b) => a - b)
                .map(l => l.toString());

            // Get all unique sectors for the filter
            const sectorList = Object.keys(sectors).sort();

            return {
                sectors: sectorList,
                hierarchy: sectorHierarchies,
                levels: sortedLevels
            };
        }

        // Recursive function to build the tree structure
        function buildTree(rootIndicator, allIndicators, sector) {
            // Ensure parent_indicator is treated as empty string if missing/null
            const parentIndicator = rootIndicator.indicador_pai || "";

            const children = allIndicators.filter(child =>
                (child.indicador_pai || "") === rootIndicator.id &&
                child.setor_estrategico === sector
            ).map(child => buildTree(child, allIndicators, sector));

            // Sort children by nivel_num to maintain hierarchy order
            if (children.length > 0) {
                children.sort((a, b) => (a.nivel_num || 0) - (b.nivel_num || 0));
            }

            return {
                id: rootIndicator.id || "",
                nome: rootIndicator.nome || "",
                nivel: rootIndicator.nivel || "Unknown",
                nivel_num: rootIndicator.nivel_num || 0,
                sector: rootIndicator.setor_estrategico || "",
                descricao: rootIndicator.descricao_simples || rootIndicator.descricao || "",
                children: children.length > 0 ? children : null
            };
        }

        // Function to calculate the height needed for a subtree
        function calculateTreeHeight(root, margin, minVerticalSpacing = 40) {
            // Calculate the maximum depth of the tree
            function getMaxDepth(node, depth = 0) {
                if (!node.children || node.children.length === 0) {
                    return depth;
                }
                let maxChildDepth = 0;
                for (const child of node.children) {
                    const childDepth = getMaxDepth(child, depth + 1);
                    if (childDepth > maxChildDepth) {
                        maxChildDepth = childDepth;
                    }
                }
                return maxChildDepth;
            }

            const maxDepth = getMaxDepth(root);
            // Use minVerticalSpacing per level
            return (maxDepth + 1) * minVerticalSpacing + margin.top + margin.bottom;
        }

        // Function to render a single subtree
        function renderSubtree(container, root, sector, rootIndex) {
            // Vertical tree: root at top, children below
            const margin = {top: 40, right: 40, bottom: 40, left: 200};
            const verticalSpacing = 60; // More space between levels vertically
            const horizontalSpacing = 180; // Space between siblings
            // Create a group for this tree with proper margins
            const svgGroup = container.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create the tree layout (vertical)
            const treeLayout = d3.tree()
                .nodeSize([horizontalSpacing, verticalSpacing]); // [x, y]: x is horizontal, y is vertical

            // Create a hierarchy from our root
            const hierarchyData = d3.hierarchy(root);
            const treeData = treeLayout(hierarchyData);

            // Draw links (lines connecting nodes)
            svgGroup.selectAll(".link")
                .data(treeData.links())
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));

            // Create a group for each node
            const nodes = svgGroup.selectAll(".node")
                .data(treeData.descendants())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .attr("data-id", d => d.data.id);

            // Add circles for the nodes
            nodes.append("circle")
                .attr("r", 10)
                .attr("class", d => `level-${d.data.nivel || 'unknown'}`);

            // Add labels to the nodes (right of node)
            nodes.append("text")
                .attr("dy", ".35em")
                .attr("x", 16)
                .style("text-anchor", "start")
                .text(d => `${d.data.id}: ${d.data.nome}`)
                .on("click", function(event, d) {
                    // Toggle children visibility
                    const node = d3.select(this.parentNode);
                    if (d.children) {
                        node.classed("collapsed", !node.classed("collapsed"));
                        // Find all descendants and toggle their display
                        const descendants = treeData.descendants().filter(n =>
                            d.data.id && n.data.id && isDescendant(d, n));
                        descendants.forEach(desc => {
                            d3.selectAll(`.node[data-id="${desc.data.id}"]`)
                                .style("display", node.classed("collapsed") ? "none" : null);
                        });
                    }
                });

            // Helper function to check if one node is a descendant of another
            function isDescendant(ancestor, node) {
                if (!node.parent || !node.parent.data) return false;
                if (node.parent.data.id === ancestor.data.id) return true;
                return isDescendant(ancestor, node.parent);
            }

            // Add tooltip or more details on hover
            nodes.on("mouseover", function(event, d) {
                d3.select(".tooltip").remove(); // Remove any existing tooltip

                const tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");

                let content = `
                    <strong>ID:</strong> ${d.data.id}<br/>
                    <strong>Nome:</strong> ${d.data.nome}<br/>
                    <strong>Nível:</strong> ${d.data.nivel}<br/>
                    <strong>Setor:</strong> ${d.data.sector}<br/>
                `;

                if (d.parent && d.parent.data && d.parent.data.id) {
                    content += `<strong>Indicador Pai:</strong> ${d.parent.data.id}: ${d.parent.data.nome}<br/>`;
                }

                if (d.data.descricao) {
                    content += `<strong>Descrição:</strong> ${d.data.descricao}`;
                }

                tooltip.html(content);
            })
            .on("mouseout", function() {
                d3.select(".tooltip").remove();
            });

            // --- Responsive SVG: set viewBox and dynamic height/width ---
            setTimeout(() => {
                try {
                    const nodeElements = container.node().querySelectorAll('.node');
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    nodeElements.forEach(el => {
                        const transform = el.getAttribute('transform');
                        if (transform) {
                            // Now using translate(x, y): x is horizontal, y is vertical
                            const match = /translate\\(([-\\d.]+),([-.\\d]+)\\)/.exec(transform);
                            if (match) {
                                const x = parseFloat(match[1]); // horizontal
                                const y = parseFloat(match[2]); // vertical
                                if (x < minX) minX = x;
                                if (x > maxX) maxX = x;
                                if (y < minY) minY = y;
                                if (y > maxY) maxY = y;
                            }
                        }
                    });
                    // Calculate width/height including margins
                    const width = (maxX - minX) + margin.left + margin.right;
                    const height = (maxY - minY) + margin.top + margin.bottom;
                    // Move the group so the tree is always visible
                    container.select('g')
                        .attr('transform', `translate(${-minX + margin.left},${-minY + margin.top})`);
                    container
                        .attr("viewBox", `0 0 ${width} ${height}`)
                        .attr("width", "100%")
                        .attr("height", height > 0 ? height : 400);
                } catch (e) {
                    // fallback: do nothing
                }
            }, 0);
        }

        // Function to check if one node is a descendant of another
        function isDescendant(ancestor, node) {
            if (!node.parent || !node.parent.data) return false;
            if (node.parent.data.id === ancestor.data.id) return true;
            return isDescendant(ancestor, node.parent);
        }

        // --- Collapsible Indented List ---
        function renderIndentedList(container, root) {
            // Recursive function to build the list
            function buildList(node) {
                const li = document.createElement('li');
                li.className = 'indented-node';
                // Node label
                const label = document.createElement('span');
                label.className = 'indented-label';
                label.innerHTML = `<strong>${node.id}</strong>: ${node.nome}`;
                // Tooltip on hover
                label.title = (node.descricao ? node.descricao + '\n' : '') + `Nível: ${node.nivel}\nSetor: ${node.sector}`;
                // Value badge placeholder
                const valueSpan = document.createElement('span');
                valueSpan.className = 'indicator-value';
                valueSpan.setAttribute('data-indicator-id', node.id);
                li.appendChild(label);
                li.appendChild(valueSpan);
                // Children
                let ul = null;
                if (node.children && node.children.length > 0) {
                    // Toggle button if has children
                    const toggle = document.createElement('span');
                    toggle.className = 'toggle';
                    toggle.textContent = '▼';
                    toggle.style.cursor = 'pointer';
                    toggle.style.marginRight = '6px';
                    let expanded = true;
                    ul = document.createElement('ul');
                    ul.className = 'indented-list';
                    node.children.forEach(child => {
                        ul.appendChild(buildList(child));
                    });
                    toggle.onclick = function() {
                        expanded = !expanded;
                        ul.style.display = expanded ? '' : 'none';
                        toggle.textContent = expanded ? '▼' : '►';
                    };
                    li.insertBefore(toggle, label);
                }
                if (ul) li.appendChild(ul);
                return li;
            }
            // Start with a <ul>
            const ul = document.createElement('ul');
            ul.className = 'indented-list';
            ul.appendChild(buildList(root));
            container.node().appendChild(ul);
        }

        // --- Update indicator values in the indented list ---
        function updateIndicatorValues(data) {
            data.forEach(record => {
                const el = document.querySelector(`.indicator-value[data-indicator-id='${record.indicator_id}']`);
                if (el) {
                    el.textContent = `${record.value} ${record.rangelabel || ''}`;
                    el.style.background = record.valuecolor || '#eee';
                    el.style.color = '#222';
                }
            });
        }

        // Function to render the hierarchy
        function renderHierarchy(hierarchyData) {
            const visualization = d3.select("#visualization");
            visualization.html(""); // Clear previous content

            // Populate sector filter
            const sectorFilter = d3.select("#sector-filter");
            sectorFilter.selectAll("option:not(:first-child)").remove();
            hierarchyData.sectors.forEach(sector => {
                sectorFilter.append("option")
                    .attr("value", sector)
                    .text(sector);
            });

            // Populate level filter
            const levelFilter = d3.select("#level-filter");
            levelFilter.selectAll("option:not(:first-child)").remove();
            hierarchyData.levels.forEach(level => {
                levelFilter.append("option")
                    .attr("value", level)
                    .text(`Nível ${level}`);
            });

            // Add event listeners for buttons
            d3.select("#collapse-all").on("click", () => {
                // Collapse all: set all toggles to collapsed
                document.querySelectorAll('.toggle').forEach(toggle => {
                    if (toggle.textContent === '▼') toggle.click();
                });
            });

            d3.select("#expand-all").on("click", () => {
                // Expand all: set all toggles to expanded
                document.querySelectorAll('.toggle').forEach(toggle => {
                    if (toggle.textContent === '►') toggle.click();
                });
            });

            // Render each sector's hierarchy
            hierarchyData.sectors.forEach(sector => {
                const sectorDiv = visualization.append("div")
                    .attr("class", "sector")
                    .attr("id", `sector-${sector.replace(/\s+/g, '-')}`);

                sectorDiv.append("div")
                    .attr("class", "sector-title")
                    .text(sector);

                const roots = hierarchyData.hierarchy[sector];
                if (roots && roots.length > 0) {
                    // If there are Level 2 roots, show them side by side
                    const level2Roots = roots.filter(r => r.nivel === '2' || r.nivel === 2);
                    const otherRoots = roots.filter(r => !(r.nivel === '2' || r.nivel === 2));
                    if (level2Roots.length > 0) {
                        const flexRow = sectorDiv.append('div').attr('class', 'level2-flex-row');
                        level2Roots.forEach((root, rootIndex) => {
                            const rootContainer = flexRow.append('div')
                                .attr('class', 'root-container level2-flex-item level2-container')
                                .style('margin-bottom', '0');
                            rootContainer.append('div')
                                .attr('class', 'root-title')
                                .text(`${root.id}: ${root.nome} (Nível ${root.nivel})`);
                            renderIndentedList(rootContainer, root);
                        });
                    }
                    // Show other roots (not Level 2) as normal blocks
                    otherRoots.forEach((root, rootIndex) => {
                        const rootContainer = sectorDiv.append('div')
                            .attr("class", "root-container")
                            .style("margin-bottom", "40px");
                        rootContainer.append("div")
                            .attr("class", "root-title")
                            .text(`${root.id}: ${root.nome} (Nível ${root.nivel})`);
                        renderIndentedList(rootContainer, root);
                    });
                } else {
                    sectorDiv.append("p").text("Nenhum indicador neste setor.");
                }
            });

            // Add event listeners for filters
            sectorFilter.on("change", function() {
                const selectedSector = this.value;
                d3.selectAll(".sector").style("display", null);
                if (selectedSector !== "all") {
                    d3.selectAll(".sector").style("display", "none");
                    d3.select(`#sector-${selectedSector.replace(/\s+/g, '-')}`).style("display", null);
                }
            });

            levelFilter.on("change", function() {
                const selectedLevel = this.value;
                if (selectedLevel === "all") {
                    d3.selectAll(".node").style("display", null);
                } else {
                    d3.selectAll(".node").style("display", function() {
                        const nodeData = d3.select(this).datum();
                        return (nodeData.data.nivel === selectedLevel) ? null : "none";
                    });
                }
            });
        }

        // Function to load and process JSON data
        function loadJsonData(jsonData) {
            // Check if data is already in the correct format
            if (Array.isArray(jsonData)) {
                // Map through the data to ensure consistent property names and formats
                const processedData = jsonData.map(item => ({
                    id: item.id || "",
                    nome: item.nome || item.name || "",
                    nivel: item.nivel || item.level || "Unknown",
                    setor_estrategico: item.setor_estrategico || item.setor || item.sector || "Unknown",
                    indicador_pai: item.indicador_pai || item.parent_indicator || item.parent || "",
                    descricao: item.descricao_simples || item.descricao || "",
                    nivel_num: item.nivel ? parseInt(item.nivel) : 0
                }));

                const hierarchyData = buildHierarchy(processedData);
                renderHierarchy(hierarchyData);
            } else {
                console.error("Invalid JSON data format");
                alert("Formato de dados inválido. Certifique-se de que o arquivo JSON contém uma matriz de indicadores.");
            }
        }

        // --- City and L2 selection logic ---
        let cityFileList = {};
        let stateCityMap = {};
        let selectedState = null;
        let selectedCity = null;

        async function loadCityFileList() {
            try {
                const resp = await fetch('data/city_filelist.json');
                if (!resp.ok) throw new Error('city_filelist.json não encontrado');
                cityFileList = await resp.json();
                // Build stateCityMap: {state: {cityId: {name, ...}}}
                stateCityMap = {};
                Object.entries(cityFileList).forEach(([cityId, info]) => {
                    if (!info.state) return;
                    if (!stateCityMap[info.state]) stateCityMap[info.state] = {};
                    stateCityMap[info.state][cityId] = info;
                });
                populateStateDropdown();
            } catch (e) {
                alert('Erro ao carregar city_filelist.json: ' + e);
            }
        }

        function populateStateDropdown() {
            const stateSelect = document.getElementById('state-select');
            stateSelect.innerHTML = '<option value="">Selecione o estado...</option>';
            Object.keys(stateCityMap).sort().forEach(state => {
                const opt = document.createElement('option');
                opt.value = state;
                opt.textContent = state;
                stateSelect.appendChild(opt);
            });
            populateCityDropdown();
        }

        function populateCityDropdown() {
            const citySelect = document.getElementById('city-select');
            citySelect.innerHTML = '<option value="">Selecione uma cidade...</option>';
            if (!selectedState || !stateCityMap[selectedState]) return;
            Object.entries(stateCityMap[selectedState]).forEach(([cityId, info]) => {
                const opt = document.createElement('option');
                opt.value = cityId;
                opt.textContent = info.name || cityId;
                citySelect.appendChild(opt);
            });
        }

        document.getElementById('state-select').addEventListener('change', function(e) {
            selectedState = e.target.value;
            selectedCity = null;
            populateCityDropdown();
        });

        document.getElementById('city-select').addEventListener('change', async function(e) {
            selectedCity = e.target.value;
            if (!selectedState || !selectedCity || !stateCityMap[selectedState][selectedCity]) return;
            // Load all indicators for this city
            try {
                const cityInfo = stateCityMap[selectedState][selectedCity];
                // Assume cityInfo.file points to the city file (e.g., PR/city_<city_code>.json)
                const resp = await fetch(`data/${cityInfo.file}`);
                if (!resp.ok) throw new Error('Arquivo da cidade não encontrado');
                const cityData = await resp.json();
                // cityData.indicators is an array of indicator records
                updateIndicatorValues(cityData.indicators || []);
                document.getElementById('file-info').textContent = `Arquivo carregado: ${cityInfo.file}`;
            } catch (err) {
                alert('Erro ao carregar arquivo da cidade: ' + err);
            }
        });

        // --- Structure file logic ---
        let structureLoaded = false;
        let structureData = null;

        // On structure file upload, build the hierarchy
        document.getElementById("json-file").addEventListener("change", function(event) {
            const file = event.target.files[0];
            if (!file) return;
            document.getElementById("file-info").textContent = `Arquivo selecionado: ${file.name}`;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    structureData = jsonData;
                    structureLoaded = true;
                    loadJsonData(jsonData); // Build the tree
                } catch (error) {
                    console.error("Erro ao analisar o arquivo JSON:", error);
                    alert("Erro ao analisar o arquivo JSON. Por favor, verifique o formato do arquivo.");
                }
            };
            reader.readAsText(file);
        });

        // Load city_filelist.json on startup
        document.addEventListener('DOMContentLoaded', loadCityFileList);

        // Reload city list button
        document.getElementById("reload-city-list").addEventListener("click", populateCityDropdown);

        // Populate on load
        document.addEventListener("DOMContentLoaded", populateCityDropdown);

        // Event listener for file upload
        document.addEventListener("DOMContentLoaded", function() {
            const fileInput = document.getElementById("json-file");
            const fileInfo = document.getElementById("file-info");

            fileInput.addEventListener("change", function(event) {
                const file = event.target.files[0];
                if (!file) return;

                fileInfo.textContent = `Arquivo selecionado: ${file.name}`;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const jsonData = JSON.parse(e.target.result);
                        structureData = jsonData;
                        structureLoaded = true;
                        loadJsonData(jsonData);
                    } catch (error) {
                        console.error("Erro ao analisar o arquivo JSON:", error);
                        alert("Erro ao analisar o arquivo JSON. Por favor, verifique o formato do arquivo.");
                    }
                };
                reader.readAsText(file);
            });

            // Sample data for testing
            const sampleData = [
                { id: "1", nome: "Indicador A", nivel: "1", setor_estrategico: "Setor 1", indicador_pai: "", descricao_simples: "Descrição do Indicador A" },
                { id: "2", nome: "Indicador B", nivel: "2", setor_estrategico: "Setor 1", indicador_pai: "1", descricao_simples: "Descrição do Indicador B" },
                { id: "3", nome: "Indicador C", nivel: "1", setor_estrategico: "Setor 2", indicador_pai: "", descricao_simples: "Descrição do Indicador C" },
                { id: "4", nome: "Indicador D", nivel: "3", setor_estrategico: "Setor 1", indicador_pai: "2", descricao_simples: "Descrição do Indicador D" },
                { id: "5", nome: "Indicador E", nivel: "2", setor_estrategico: "Setor 2", indicador_pai: "3", descricao_simples: "Descrição do Indicador E" },
                { id: "6", nome: "Indicador F", nivel: "1", setor_estrategico: "Setor 3", indicador_pai: "", descricao_simples: "Descrição do Indicador F" },
                { id: "7", nome: "Indicador G", nivel: "2", setor_estrategico: "Setor 1", indicador_pai: "1", descricao_simples: "Descrição do Indicador G" },
                { id: "8", nome: "Indicador H", nivel: "3", setor_estrategico: "Setor 2", indicador_pai: "5", descricao_simples: "Descrição do Indicador H" },
                { id: "9", nome: "Indicador I", nivel: "4", setor_estrategico: "Setor 1", indicador_pai: "4", descricao_simples: "Descrição do Indicador I" },
                { id: "10", nome: "Indicador J", nivel: "1", setor_estrategico: "Setor 3", indicador_pai: "", descricao_simples: "Descrição do Indicador J" },
                { id: "11", nome: "Indicador K", nivel: "2", setor_estrategico: "Setor 3", indicador_pai: "10", descricao_simples: "Descrição do Indicador K" },
                { id: "12", nome: "Indicador L", nivel: "3", setor_estrategico: "Setor 3", indicador_pai: "11", descricao_simples: "Descrição do Indicador L" }
            ];

            // For testing, you can uncomment this to load sample data by default
            // loadJsonData(sampleData);
        });

        // Function to collapse all nodes in a tree
        function collapseAllNodes() {
            d3.selectAll(".node").each(function(d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                }
            });
            d3.selectAll(".node").style("display", function(d) {
                return d.depth === 0 ? null : "none";
            });
        }

        // Function to expand all nodes in a tree
        function expandAllNodes() {
            d3.selectAll(".node").each(function(d) {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            });
            d3.selectAll(".node").style("display", null);
        }
    </script>
</body>
</html>
